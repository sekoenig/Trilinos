//@HEADER
// ************************************************************************
//
//                 Belos: Block Linear Solvers Package
//                  Copyright 2004 Sandia Corporation
//
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact Jennifer A. Loe (jloe@sandia.gov)
//
// ************************************************************************
//@HEADER

/*! \file BelosKokkosSingleSolverOp.h
    \brief This file provides a Belos::Operator interface for Kokkos so 
     that single precision preconditioners can be used with double precision
     linear problems. 
*/

#ifndef BELOS_KOKKOS_SING_SOLVER_OP_H
#define BELOS_KOKKOS_SING_SOLVER_OP_H

#include "BelosOperator.hpp"

#include "BelosLinearProblem.hpp"
#include "BelosKokkosAdapter.hpp"
#include "BelosSolverFactory.hpp"

#include "Teuchos_ParameterList.hpp"

/*! \class Belos::KokkosSingleSolverOp
    \brief This class provides an interface to the Belos::Operator class for Kokkos, so Belos can be 
    integrated into other Kokkos codes as an abstract operator. 
    Thus, it can use itself as a preconditioner if need be.  It can
    also be used as the inner iteration of Anasazi :)
*/

namespace Belos {

template<class InOutScalarT=double, class SolveScalarT=float, class OrdinalType=int, class Device=Kokkos::DefaultExecutionSpace>
class KokkosSingleSolverOp : public Operator<InOutScalarT> {
private:

  // Typedefs:
  using MultiVector = MultiVec<SolveScalarT>;
  using Op = Operator<SolveScalarT>; 
  using Kokkos_MultiVector_InOut = KokkosMultiVec<InOutScalarT, Device>;
  using Kokkos_MultiVector_Solve = KokkosMultiVec<SolveScalarT, Device>;
  using Kokkos_Operator_Solve = KokkosCrsOperator<SolveScalarT, OrdinalType, Device>; 

  //Teuchos::RCP<SolverManager<SolveScalarT,Kokkos_MultiVector_Solve,Kokkos_Operator_Solve> > solver_;
  //Teuchos::RCP<LinearProblem<SolveScalarT,Kokkos_MultiVector_Solve,Kokkos_Operator_Solve> > lp_;
  Teuchos::RCP<SolverManager<SolveScalarT,MultiVector,Op> > solver_;
  Teuchos::RCP<LinearProblem<SolveScalarT,MultiVector,Op> > lp_;
  Teuchos::RCP<Teuchos::ParameterList> plist_;

  //! Name of solver to be passed into solver factory. 
  std::string solver_name_;

  /// \brief True if KokkosCrsOperator should initialize the solution vector to zero before
  ///   calling 'solve' in the 'apply' function.  
  bool initSolnVec_;

public:

  //! @name Constructor / Destructor
  //@{ 
  
    /// \brief Create a KokkosSingleSolverOp from the Belos solver \c solver_name  generated by Belos' solver factory.
    ///
    /// The solver is initialized with a LinearProblem (\c lp) and ParameterList (\c plist).
    ///
    /// One should create a new linear problem to pass to the inner solver which is separate
    /// from the linear problem passed to any outer solver. (Both problems may have the same 
    /// operator, but solution and right-hand side vectors need to be maintained separately.)  
    ///
    /// When true, the bool \c initSolnVec causes the solution vector \c Y to be itialized to zero
    /// when apply(X,Y) is called.

  KokkosSingleSolverOp( const Teuchos::RCP<LinearProblem<SolveScalarT,MultiVector,Op> >& lp, 
		  const Teuchos::RCP<Teuchos::ParameterList>& plist,
      const std::string solver_name="GmresPoly",
      bool initSolnVec = false )  
  : lp_(lp), 
    plist_(plist),
    solver_name_(solver_name),
    initSolnVec_(initSolnVec)
  {
    Belos::SolverFactory<SolveScalarT,MultiVector,Op> factory;
    solver_ = factory.create( solver_name_, plist );
    solver_->setProblem( lp_ );
  }

  
  //! Destructor
  virtual ~KokkosSingleSolverOp() = default;
  //@}
  
  //! @name Operator application methods
  //@{ 
  
  /// \brief Apply the operator.  Performs a linear solve with right-hand side \c X.
  /// Solution is stored in \c Y.  If \c initSolnVec was set to true, the vector \c Y
  /// will be initialized with zeros before calling solve.  If \c initSolnVec is false, 
  /// the vector \c Y will be used as an initial guess for the linear solve.  
  ///
  /// When using the GmresPoly solver, the polynomial will be applied to \c X at each call
  /// instead of performing a linear solve.  

  void Apply (const MultiVec<InOutScalarT>& x,  MultiVec<InOutScalarT>& y,  ETrans trans=NOTRANS) const{
    switch(trans){
      case NOTRANS:
        break;
      case TRANS:
        TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error,
            "Belos::KokkosSingleSolverOp::Apply: Transpose not supported. ");
      case CONJTRANS:
        TEUCHOS_TEST_FOR_EXCEPTION(true, std::runtime_error,
            "Belos::KokkosSingleSolverOp::Apply: Transpose not supported. ");
      default:
        TEUCHOS_TEST_FOR_EXCEPTION(true, std::invalid_argument,
            "Belos::KokkosCrsOperator::Apply: Invalid ETrans type ");
    }
    //We don't need any input from Y.  Only need to copy X from double -> float.
    //TODO: Is this really the best way to do this here? Can we do it without the pointers and use rcpFromRef?
    KokkosMultiVec<SolveScalarT, Device> x_solve(dynamic_cast<KokkosMultiVec<InOutScalarT, Device>& >
            (const_cast<MultiVec<InOutScalarT>&>(x)));
    int numRows = x_solve.GetGlobalLength();
    KokkosMultiVec<SolveScalarT, Device> y_solve(numRows);
    Teuchos::RCP<const Kokkos_MultiVector_Solve> vec_X = Teuchos::rcpFromRef(x_solve);
    Teuchos::RCP<Kokkos_MultiVector_Solve> vec_Y = Teuchos::rcpFromRef(y_solve);
    if (initSolnVec_)
    {
      vec_Y->MvInit( 0.0 );
      lp_->setInitResVec( vec_X );
    }
    lp_->setProblem( vec_Y, vec_X );
    solver_->solve();
    //X is const, so only need to copy Y for output.
    dynamic_cast<KokkosMultiVec<InOutScalarT, Device>&>(y) = y_solve;
  };
  //@}
  
  //! @name Attribute access functions
  //@{ 

  //! Return the name of the requested solver.
  const std::string getSolverName() const { return solver_name_; };
  
  //! Return whether the operator supports applying its transpose or conjugate transpose.
  bool HasApplyTranspose () const {
    return false;
  }
  //@}	   

};

} //end namespace Belos

// end of file BELOS_KOKKOS_SING_SOLVER_OP_H
#endif 

